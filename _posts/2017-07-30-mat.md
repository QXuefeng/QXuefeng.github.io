---
layout: post
title: 文件I/O
date: 2018-04-07 20:45
categories: 测试
tags: 测试
---


> **文件I/O** 指的是对系统文件的操作， 如打开、读取等
**不带缓存的I/O** 指每个操作都调用内核中的一个系统调用
本节主要介绍的文件I/O函数都是不带缓存的I/O

# 1. 文件描述符
> **文件描述符** 是一个非负整型, 用于引用所打开的文件
当打开或创建一个文件时，内核都会向进程返回一个文件描述符

文件描述符的范围是 0 - OPEN_MAX(limits.h中,表每个进程最多打开的文件数, 有系统做出规定，也有些不做规定),在这些范围中有些已经被标准定义为常数(文件<unistd.h>)，无法在被使用，如下：

  幻数 | 符号常量 | 意义
:------------: | :-------------: | :------------:
0 |  STDIN_ILENO  | 标准输入
1 |  STDOUT_FILENO |  标准输出
2 | STDERR_FILENO  | 标准错误

# 2. open函数
> **头文件** fcntl.h
**原型** int open(const char *pathname, int oflag, .../*, mode_t mode * / ) ;
**作用** 打开文件，成功返回文件描述符, 错误返回-1
**简述** pathname是要打开或创建的文件的名字.
oflag参数可用来说明此函数的多个选择项, 定义在函数的头文件中, 对个多个选项进行|运算叠加
>
 选择常量 | 意义
:-------------: | :------------:
O_RDONLY  | 只读打开
O_WRONLY  | 只写打开
O_RDWR  | 读、写打开
O_APPEND  | 文件尾部写入
O_CREAT  | 文件不存在则创建它, 需同时说明第三个参数 mode，用其说明该新文件的存取许可权位
O_EXCL  | 同时指定了O_CREAT，而文件已经存在，则出错
O_TRUNC  | 如果如果文件存在，成功只读\写打开，则清空文件数据
O_NOCTTY  | 若pathname指的是终端设备，则不将此设备分配作为此进程的控制终端
O_NONBLOCK  | 若pathname指的是FIFO、块文件或字符文件，则此选择项为此文件的本次打开操作和后续的I/O操作设置非阻塞方式
O_SYNC  | 同步, 每次write都等到物理I/O操作完成
>
若pathname超出的NAME_MAX(limits.h中,表示文件名中的最大字节数, 不包括null), 行为将是未定义的.

# 3. creat函数
>**头文件** fcntl.h
**原型** int creat(const char *pathname, mode_t mode) ;
**作用** 只写的创建新文件，成功返回文件描述符, 错误返回-1
**简述** 等效于open(pathname, O_WRONL｜YO_CREAT｜O_TRUNC, mode) ;

# 4. close函数
>**头文件** fcntl.h
**原型** int close (int filedes)；
**作用** 关闭打开的文件，成功返回0, 错误返回-1
**简述** 关闭一个文件时也释放该进程加在该文件上的所有记录锁. 而当进程结束时，内核也会自动关闭本进程打开的所有文件

# 5. lseek函数
>**头文件** fcntl.h
**原型** off_t lseek(int filedes, off_t offset, int whence) ;
**作用** 控制当前文件位移量，成功返回新的文件位移，出错为- 1
**简述** 对参数offset 的解释与参数whence的值有关。
• 若whence是SEEK_SET，则将该文件的位移量设置为距文件开始处 offset 个字节。
• 若whence是SEEK_CUT，则将该文件的位移量设置为其当前值加offset, offset可为正或负。
• 若whence是SEEK_END，则将该文件的位移量设置为文件长度加offset, offset可为正或负
文件的offset可以大于文件的大小, 超出的部分会被0填空

<center>**<font color='red'>例 创建空洞文件</font>**</center>
```c
#include <fcntl.h>
#include "apue.h"

char buf1[] = "abcdefghij";
char buf2[] = "0123456789";

int main(void)
{
    int fd;
    if((fd = creat("file.hole", FILE_MODE)) < 0)
        err_sys("creat error");
    /* offset = 0 */

    if(write(fd, buf1, 10) != 10)
        err_sys("write buf1 error");
    /* offset = 10 */

    if(lseek(fd, 40, SEEK_SET) == -1)
        err_sys("lseek error");
    /* offset = 40 */

    if(write(fd, buf2, 10) != 10)
        err_sys("write buf1 error");
    /* offset = 50 */

    return 0;
}
```
![](https://qxuefeng.github.io/assets/img/res/20180407214959.png)

# 6. read函数
>**头文件** unistd.h
**原型** ssize_t read(int filedes, void *buff, size_t nbytes);
**作用** 读文件数据，成功返回buf的字节数,出错为- 1
**简述** • filedes是文件描述符
• buf是数据存放的位置
• nbytes一次读取的字节数， 大于文件剩余的字节时，读取文件剩余的所有的数据

# 7. write函数
>**头文件** unistd.h
**原型** ssize_t write((int filedes, const void *buff, size_t nbytes);
**作用** 写数据到文件，成功返回数据的字节数,出错为- 1
**简述** • filedes是文件描述符
• buf是数据存放的位置
• nbytes一次写的字节数大小

# 8. I/O效率
读1 468 802字节文件所得到的结果测试BUFFSIZE大小对时间效率的影响, 测试代码如下
```c
#include "apue.h"

#define	BUFFSIZE	4096

int main(void)
{
	int	 n;
	char buf[BUFFSIZE];

	while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0)
		if (write(STDOUT_FILENO, buf, n) != n)
			err_sys("write error");
	if (n < 0) err_sys("read error");

	exit(0);
}
```
使用命令time -p 程序可以进行测试，结果如下：
![]({{site.url}}/assets/img/res/20180407222326.png)
可以发现BUFFSIZE大于8192byte后，时间就无明显变化了



